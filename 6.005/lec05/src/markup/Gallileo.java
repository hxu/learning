package markup;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/**
 * A Gallileo object is a parser/evaluator for markdown that scrambles
 * italic text (generates a random anagram of each italic part) so that Kepler can't read it.
 */
public class Gallileo {
    
    private final MarkdownLexer lex;
    
    public Gallileo(String markdown) {
        this.lex = new MarkdownLexer(markdown);
    }
    
    /**
     * Evaluate the input text, scrambling italic sections.
     * Can be called only once on a given object.
     * Modifies this object, consuming all the text.
     * @return string of text with markdown formatting removed
     * and italic sections replaced by a random anagram.
     * For example, new Gallileo("The killer was _Mrs. White_").eval()
     * ==> "The killer was hrW.sM tie"
     */
    public String eval() {
        return evalMarkdown();
    }
    
    // Grammar:
    //   Markdown ::= (Normal | Italic)*
    //   Normal ::= Text
    //   Italic ::= _ Text? _
    //
    //  (Text and _ are tokens generated by MarkdownLexer)
    
    /**
     * Evaluates the Markdown production of the grammar.
     * Modifies lex by consuming all the remaining tokens.
     * @return evaluated string
     */
    private String evalMarkdown() {
        StringBuilder sb = new StringBuilder();
        
        for (Token tok = lex.next(); tok.getType() != Type.EOF; tok = lex.next()) {
            switch (tok.getType()) {
            case UNDERLINE:
                sb.append(evalItalic(tok));
                break;    
            case TEXT:
                sb.append(evalNormal(tok));
                break;
            default:
                throw new AssertionError("unexpected token: " + tok.getType());
            }
        }
        
        return sb.toString();
    }
    
    /**
     * Evaluates the Normal production of the grammar.
     * Modifies lex by consuming an entire production, including the last token of the production.
     * @param tok Token that started this production (required to be TEXT)
     * @return evaluated string
     */
    private String evalNormal(Token tok) {
        // normal text isn't changed by this process, just return it as-is
        return tok.getValue();
    }

    /**
     * Evaluates the Italic production of the grammar.
     * Modifies lex by consuming an entire Italic production, including its final token.
     * @param tok Token that started this production (required to be UNDERLINE)
     * @return evaluated string
     */
    private String evalItalic(Token tok) {
        StringBuilder sb = new StringBuilder();
        
        // the passed in tok is UNDERLINE; skip it and advance to the next
        
        // note that this code actually evaluates _ TEXT* _, not just _ TEXT? _
        for (tok = lex.next(); tok.getType() != Type.EOF && tok.getType() != Type.UNDERLINE; tok = lex.next()) {
            if (tok.getType() == Type.TEXT) {
                // collect and shuffle the text
                sb.append(shuffle(tok.getValue()));
            } else {
                throw new AssertionError("unexpected token: " + tok.getType());                
            }
        }
        
        return sb.toString();
    }
    
    /**
     * Make a random anagram of a string.
     * @param s string to rearrange
     * @return a random permutation of the characters in s.
     * For example, shuffle("abc") might return "bca" or "cba" or "abc".
     */
    static String shuffle(String s) {
        // this is not the best way to implement this -- what would be better?

        // split with empty-string separator to get each char as a string
        String[] a = s.split(""); // e.g. "", "a", "b", "c"    (produces an extra empty string, but that won't hurt)

        List<String> l = Arrays.asList(a);
        Collections.shuffle(l);   // now it's shuffled, e.g. "a", "", "c", "b"
        
        // glue the shuffled list back together into one string
        StringBuilder sb = new StringBuilder();
        for (String t : l) {
            sb.append(t);
        }
        
        return sb.toString();
    }
    
    
    /**
     * Main method.
     */
    public static void main(String[] args) {
        Gallileo g = new Gallileo("I've discovered that _Saturn has ears_.  Suck it, Kepler!");
        String message = g.eval();
        System.out.println(message);
    }
}
